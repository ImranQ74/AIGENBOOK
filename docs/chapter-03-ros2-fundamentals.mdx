---
title: Chapter 3 - ROS 2 Fundamentals
description: Master the Robot Operating System 2 framework for building robot applications
---

# ROS 2 Fundamentals

ROS 2 (Robot Operating System 2) is the de facto standard framework for building robot applications. It provides hardware abstraction, device drivers, message passing, and tools for building complex robot systems.

## 3.1 Why ROS 2?

### Evolution from ROS 1

| Feature | ROS 1 | ROS 2 |
|---------|-------|-------|
| **Real-time** | Limited | Full support |
| **Security** | None | DDS security |
| **Lifecycle** | Manual | Managed nodes |
| **Platforms** | Ubuntu only | Cross-platform |
| **GUI Tools** | Basic | Enhanced |

### Core Design Principles
- **Modularity**: Build small, reusable components
- **Abstraction**: Hide hardware details
- **Communication**: Message passing between nodes
- **Tooling**: Rich development ecosystem

## 3.2 The ROS 2 Ecosystem

```
┌─────────────────────────────────────────────────────────────┐
│                      ROS 2 TOOLS                            │
│   • rviz2 (Visualization)   • rosbag2 (Recording)          │
│   • gazebo_ros (Simulation) • colcon (Build)               │
├─────────────────────────────────────────────────────────────┤
│                   ROS 2 CLIENT LIBRARIES                    │
│   • rclcpp (C++)   • rclpy (Python)   • rcljava (Java)     │
├─────────────────────────────────────────────────────────────┤
│                    ROS 2 CORE (RCL)                         │
│   • Node management   • Parameter service                   │
│   • Lifecycle state machine   • Time management             │
├─────────────────────────────────────────────────────────────┤
│              DDS (Data Distribution Service)                │
│   • Fast-DDS   • CycloneDDS   • Connext                      │
└─────────────────────────────────────────────────────────────┘
```

## 3.3 Basic Concepts

### Nodes

A ROS 2 node is a single-purpose executable:

```python
# minimal_node.py
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Hello from ROS 2!')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Topics (Publish/Subscribe)

```
Topic Communication Pattern:

    Publisher Node          Topic           Subscriber Node
    ┌──────────────┐                      ┌──────────────┐
    │              │  ──chatter_topic───> │              │
    │  /chatter    │                      │  /listener   │
    │  (String)    │                      │  (String)    │
    └──────────────┘                      └──────────────┘
```

```python
# publisher.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Publisher(Node):
    def __init__(self):
        super().__init__('publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello ROS 2!'
        self.publisher_.publish(msg)

# subscriber.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Subscriber(Node):
    def __init__(self):
        super().__init__('subscriber')
        self.subscription = self.create_subscription(
            String, 'chatter', self.listener_callback, 10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'Heard: "{msg.data}"')
```

### Services (Request/Response)

```
Service Communication Pattern:

    Client Node           Service          Server Node
    ┌──────────┐                        ┌──────────┐
    │  add     │  ──(request)─────────> │          │
    │  two     │                        │  /add    │
    │  ints    │  <──(response)──────── │  two     │
    └──────────┘                        └──────────┘
```

```python
# service_server.py
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class ServiceServer(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_callback)

    def add_callback(self, request, response):
        response.sum = request.a + request.b
        return response
```

### Actions (Long-running Tasks)

Actions are for tasks that take time and can be cancelled:

```python
# action_server.py
from action_msgs.msg import GoalStatus
from nav2_msgs.action import NavigateToPose
import rclpy
from rclpy.action import ActionServer

class NavServer(Node):
    def __init__(self):
        super().__init__('nav_server')
        self._action_server = ActionServer(
            self, NavigateToPose, 'navigate_to_pose', self.execute_callback)

    def execute_callback(self, goal_handle):
        # Execute navigation logic
        result = NavigateToPose.Result()
        return result
```

## 3.4 Launch Files

Orchestrate multiple nodes:

```python
# launch/demo.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='pkg1',
            executable='publisher',
            name='publisher_node'
        ),
        Node(
            package='pkg2',
            executable='subscriber',
            name='subscriber_node',
            parameters=[{'param_file': 'config.yaml'}]
        ),
    ])
```

## 3.5 Workspaces and Packages

### Creating a Workspace

```bash
# Create workspace structure
mkdir -p ~/ws/src
cd ~/ws

# Source ROS 2
source /opt/ros/humble/setup.bash

# Create a package
cd src
ros2 pkg create my_robot_pkg --dependencies rclpy std_msgs

# Build the workspace
colcon build

# Source the workspace
source install/setup.bash
```

### Package Structure

```
my_robot_pkg/
├── package.xml
├── setup.py
├── setup.cfg
├── resource/
├── my_robot_pkg/
│   ├── __init__.py
│   └── my_node.py
└── launch/
    └── demo.launch.py
```

## 3.6 Common Tools

```bash
# List active nodes
ros2 node list

# List topics
ros2 topic list

# Echo topic messages
ros2 topic echo /chatter

# Show topic info
ros2 topic info /chatter

# Call a service
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 5, b: 10}"

# Record a bag
ros2 bag record -o output_bag /chatter

# Visualize with rviz
rviz2
```

## 3.7 Learning Objectives

After this chapter, you will understand:
- [ ] The architecture and design of ROS 2
- [ ] How to create and run ROS 2 nodes
- [ ] Topic, service, and action communication patterns
- [ ] How to use launch files and workspace tools
- [ ] Common ROS 2 command-line tools

## 3.8 Hands-On Exercise

Create a simple publisher-subscriber pair that controls an LED:

```python
# led_publisher.py
# Publishes LED state (0=off, 1=on) to /led_state topic
```

```python
# led_subscriber.py
# Subscribes to /led_state and prints the LED status
```

Run both nodes and verify communication.

## Quiz

1. What are the three main communication patterns in ROS 2?
2. How does a service differ from a topic?
3. When would you use actions instead of services?

---
*Previous: [Chapter 2 - Humanoid Robotics](/docs/chapter-02-humanoid-robotics) | Next: [Chapter 4 - Digital Twin Simulation](/docs/chapter-04-digital-twin)*
